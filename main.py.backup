#!/usr/bin/env python3
"""
Robot-Crypt: Bot de Negocia√ß√£o para Binance
Estrat√©gia de baixo risco e progress√£o sustent√°vel
"""
import time
import logging
import json
import requests
import signal
import sys
import os
from datetime import datetime, timedelta
from binance_api import BinanceAPI
from strategy import ScalpingStrategy, SwingTradingStrategy
from config import Config
from utils import setup_logger, save_state, load_state, filtrar_pares_por_liquidez
from telegram_notifier import TelegramNotifier
from db_manager import DBManager
from pathlib import Path

# Configura√ß√£o de logging
logger = setup_logger()

# Vari√°veis globais para controle de sinal
SHOULD_EXIT = False

# Fun√ß√£o para tratamento de sinais
def signal_handler(sig, frame):
    global SHOULD_EXIT
    logger.info(f"Sinal {sig} recebido, preparando para encerramento gracioso...")
    SHOULD_EXIT = True

# Registra handlers para sinais
signal.signal(signal.SIGTERM, signal_handler)
signal.signal(signal.SIGINT, signal_handler)

def initialize_resources():
    """Inicializa recursos b√°sicos do sistema"""
    logger.info("Iniciando inicializa√ß√£o do Robot-Crypt")
    
    # Verifica e cria diret√≥rios necess√°rios
    for directory in ['data', 'logs', 'reports']:
        dir_path = Path(__file__).parent / directory
        if not dir_path.exists():
            dir_path.mkdir(exist_ok=True, parents=True)
            logger.info(f"Diret√≥rio {directory} criado com sucesso")
    
    # Carrega configura√ß√£o
    config = Config()
    
    # Debug para Telegram
    logger.info(f"Telegram Token dispon√≠vel: {'Sim' if config.telegram_bot_token else 'N√£o'}")
    logger.info(f"Telegram Chat ID dispon√≠vel: {'Sim' if config.telegram_chat_id else 'N√£o'}")
    logger.info(f"Notifica√ß√µes Telegram habilitadas: {'Sim' if config.notifications_enabled else 'N√£o'}")
    
    # Inicializa banco de dados SQLite
    db = DBManager()
    logger.info("Banco de dados SQLite inicializado com sucesso")
    
    # Inicializa notificador Telegram, se configurado
    notifier = None
    if config.notifications_enabled:
        notifier = TelegramNotifier(config.telegram_bot_token, config.telegram_chat_id)
    
    # Inicializa conex√£o com Binance
    if config.simulation_mode:
        logger.info("MODO DE SIMULA√á√ÉO ATIVADO - N√£o ser√° feita conex√£o real com a Binance")
        logger.info("Os dados de mercado e opera√ß√µes ser√£o simulados")
        
        # Importa e inicializa o simulador 
        from binance_simulator import BinanceSimulator
        binance = BinanceSimulator()
        
        # Notifica sobre o modo de simula√ß√£o
        if notifier:
            notifier.notify_status("üîÑ Robot-Crypt iniciado em MODO DE SIMULA√á√ÉO!")
    else:
        # Inicializa conex√£o real com a Binance
        logger.info("Conectando √† API da Binance...")
        
        if config.use_testnet:
            logger.info("Usando Binance Testnet (ambiente de testes)")
            if notifier:
                notifier.notify_status("üîÑ Robot-Crypt iniciado em MODO TESTNET!")
        else:
            logger.info("Conectando a Binance em modo de PRODU√á√ÉO!")
            logger.info("!!! ATEN√á√ÉO !!! Opera√ß√µes com dinheiro real ser√£o executadas!")
            if notifier:
                notifier.notify_status("‚ö†Ô∏è Robot-Crypt iniciado em MODO DE PRODU√á√ÉO!")
                
        # Inicializa API da Binance
        binance = BinanceAPI(
            api_key=config.api_key,
            api_secret=config.api_secret,
            testnet=config.use_testnet
        )
        
        # Testa conex√£o
        logger.info("Testando conex√£o com a API da Binance...")
        connection_status = binance.test_connection()
        if connection_status:
            logger.info("Conex√£o com a Binance estabelecida com sucesso")
        else:
            logger.error("Falha ao conectar √† API da Binance. Encerrando.")
            if notifier:
                notifier.notify_alert("‚ùå FALHA DE CONEX√ÉO com a Binance. Robot-Crypt n√£o iniciado!")
            return None, None, None

    logger.info("Inicializa√ß√£o conclu√≠da com sucesso")
    
    # Pausa para garantir que o container esteja est√°vel
    logger.info("Aguardando 10 segundos antes de iniciar opera√ß√µes...")
    for i in range(10, 0, -1):
        if SHOULD_EXIT:
            logger.info("Encerramento solicitado durante a inicializa√ß√£o")
            return None, None, None
        logger.info(f"Iniciando opera√ß√µes em {i} segundos...")
        time.sleep(1)
    
    return config, binance, notifier, db

def main():
    """Fun√ß√£o principal do bot"""
    logger.info("Iniciando Robot-Crypt Bot")
    
    # Fase de inicializa√ß√£o - estabelece conex√µes e prepara recursos
    config, binance, notifier, db = initialize_resources()
    
    # Verifica se a inicializa√ß√£o foi bem-sucedida
    if not config or not binance:
        logger.error("Falha na inicializa√ß√£o dos recursos necess√°rios. Encerrando.")
        return
        
    # A partir daqui, √© o c√≥digo original do main.py
    
    # Verifica se estamos em modo de simula√ß√£o
    if config.simulation_mode:
        logger.info("MODO DE SIMULA√á√ÉO ATIVADO - N√£o ser√° feita conex√£o real com a Binance")
        logger.info("Os dados de mercado e opera√ß√µes ser√£o simulados")
        
        # Importa e inicializa o simulador 
        from binance_simulator import BinanceSimulator
        binance = BinanceSimulator()
        
        # Notifica sobre o modo de simula√ß√£o
        if notifier:
            notifier.notify_status("Robot-Crypt iniciado em MODO DE SIMULA√á√ÉO! üöÄ")
    else:
        # Inicializa API da Binance real
        binance = BinanceAPI(config.api_key, config.api_secret, testnet=config.use_testnet)
        
        # Log sobre o modo de opera√ß√£o
        if config.use_testnet:
            logger.info("MODO TESTNET ATIVADO - Conectando √† TestNet da Binance (ambiente de teste)")
            logger.info("Aten√ß√£o: Nem todos os pares est√£o dispon√≠veis na TestNet")
        else:
            logger.info("MODO PRODU√á√ÉO ATIVADO - Conectando √† API real da Binance com dinheiro real")
        
        # Notifica sobre o in√≠cio do bot
        if notifier:
            msg = "Robot-Crypt iniciado em TESTNET! üöÄ" if config.use_testnet else "Robot-Crypt iniciado em PRODU√á√ÉO! üöÄ"
            notifier.notify_status(msg)
        
        # Primeiro, testa a conex√£o com a API
        logger.info("Testando conex√£o com a API da Binance...")
    # S√≥ testamos a conex√£o se n√£o estivermos em modo de simula√ß√£o
    if not config.simulation_mode and not binance.test_connection():
        error_message = "Falha na conex√£o com a API da Binance. Verifique suas credenciais."
        logger.error(error_message)
        
        # Se for testnet, mostra instru√ß√µes especiais
        if config.use_testnet:
            logger.error("ATEN√á√ÉO: Para usar a testnet da Binance, voc√™ precisa de credenciais espec√≠ficas.")
            logger.error("1. Acesse https://testnet.binance.vision/")
            logger.error("2. Fa√ßa login com sua conta Google/Github")
            logger.error("3. Gere um par de API Key/Secret espec√≠fico para testnet")
            logger.error("4. Execute ./setup_testnet.sh para configurar suas credenciais")
            logger.error("")
            logger.error("Alternativa: Configure o modo de simula√ß√£o adicionando SIMULATION_MODE=true no arquivo .env")
            
        if notifier:
            notifier.notify_error(f"{error_message} Verifique os logs para mais detalhes.")
        
        logger.info("Finalizando Bot devido a erro de autentica√ß√£o")
        return
    
    # Verifica saldo da conta
    try:
        max_retries = 3
        retry_count = 0
        account_info = None
        
        # Implementa l√≥gica de retry para lidar com timeouts
        while retry_count < max_retries:
            try:
                logger.info(f"Tentando obter informa√ß√µes da conta (tentativa {retry_count + 1}/{max_retries})...")
                account_info = binance.get_account_info()
                break  # Se bem-sucedido, sai do loop
            except requests.exceptions.RequestException as e:
                retry_count += 1
                if retry_count < max_retries:
                    wait_time = 5 * retry_count  # Espera progressivamente mais tempo
                    logger.warning(f"Erro de conex√£o: {str(e)}. Tentando novamente em {wait_time} segundos...")
                    time.sleep(wait_time)
                else:
                    logger.error(f"Falha ap√≥s {max_retries} tentativas. Usando dados padr√£o.")
                    # Cria uma estrutura m√≠nima para permitir que o programa continue
                    account_info = {"balances": []}
        
        # Log detalhado das informa√ß√µes da conta para depura√ß√£o
        logger.info("Informa√ß√µes detalhadas da conta Binance:")
        if 'balances' in account_info and account_info['balances']:
            for balance in account_info['balances']:
                try:
                    asset = balance.get('asset', '')
                    free = float(balance.get('free', '0'))
                    locked = float(balance.get('locked', '0'))
                    total = free + locked
                    if total > 0:
                        logger.info(f"Moeda: {asset}, Livre: {free}, Bloqueado: {locked}, Total: {total}")
                except Exception as e:
                    logger.error(f"Erro ao processar saldo da moeda: {str(e)}")
        else:
            logger.warning("Dados da conta vazios ou n√£o cont√™m o campo 'balances' com valores. Usando saldo padr√£o.")
            # N√£o mostra a estrutura JSON para evitar erro se account_info for None
        
        # Obt√©m o saldo total da conta em BRL/USDT ou usa valor padr√£o
        logger.info("Calculando saldo total convertido...")
        try:
            # Tenta obter o saldo real
            capital = config.get_balance(account_info) if account_info else 100.0
        except Exception:
            # Se falhar por qualquer motivo, usa valor padr√£o
            logger.warning("Erro ao calcular saldo. Usando valor padr√£o.")
            capital = 100.0
            
        logger.info(f"Saldo total convertido: R${capital:.2f}")
        
        # Notifica saldo via Telegram
        if notifier:
            try:
                notifier.notify_status(f"Saldo atual: R${capital:.2f}")
            except Exception as notify_error:
                logger.error(f"Erro ao enviar notifica√ß√£o sobre saldo: {str(notify_error)}")
                
    except Exception as e:
        logger.error(f"Erro ao obter informa√ß√µes da conta: {str(e)}")
        logger.error("Usando valor padr√£o para o capital")
        capital = 100.0
    
    # Inicializa estrat√©gia conforme o saldo dispon√≠vel
    strategy = None
    pairs = []
    state_save_counter = 0
    start_time = datetime.now()
    
    # Carrega o estado anterior da aplica√ß√£o
    previous_state = load_state()
    
    # Se n√£o houver estado em arquivo, tenta carregar do banco de dados
    if not previous_state:
        logger.info("Nenhum arquivo de estado encontrado, tentando carregar do banco de dados...")
        previous_state = db.load_last_app_state()
        
        # Se encontrou no banco de dados, salva tamb√©m como arquivo para compatibilidade
        if previous_state:
            logger.info("Estado carregado do banco de dados com sucesso")
            save_state(previous_state)
            logger.info("Estado migrado do banco de dados para arquivo JSON")
    
    # Inicializa estat√≠sticas
    stats = {}
    
    # Define a estrat√©gia inicial e os pares com base no capital
    logger.info(f"Inicializando estrat√©gia com capital de R${capital:.2f}")
    
    # Se temos configura√ß√£o expl√≠cita de pares, usamos ela como base
    config_pairs = getattr(config, 'trading_pairs', [])
    if config_pairs:
        logger.info(f"Usando pares configurados: {config_pairs}")
        pairs = config_pairs
    
    # Seleciona estrat√©gia baseada no capital
    if capital < 300:
        logger.info("Inicializando com estrat√©gia de Scalping (capital < R$300)")
        strategy = ScalpingStrategy(config, binance)
        
        # Define pares padr√£o para Scalping se n√£o tiver configura√ß√£o expl√≠cita
        if not pairs:
            if config.use_testnet:
                pairs = ["BTC/USDT", "ETH/USDT", "BNB/USDT"]
                logger.info("Usando pares padr√£o compat√≠veis com testnet para scalping")
            else:
                pairs = ["BTC/USDT", "ETH/USDT", "DOGE/USDT", "SHIB/USDT"]
                logger.info("Usando pares padr√£o para scalping")
    else:
        logger.info("Inicializando com estrat√©gia de Swing Trading (capital >= R$300)")
        strategy = SwingTradingStrategy(config, binance)
        
        # Define pares padr√£o para Swing Trading se n√£o tiver configura√ß√£o expl√≠cita
        if not pairs:
            if config.use_testnet:
                pairs = ["BTC/USDT", "ETH/USDT", "XRP/USDT", "LTC/USDT", "BNB/USDT"] 
                logger.info("Usando pares padr√£o compat√≠veis com testnet para swing trading")
            else:
                pairs = ["BTC/USDT", "ETH/USDT", "DOGE/USDT", "SHIB/USDT", "FLOKI/USDT"]
                # Remova ETH/BNB especificamente pois sabemos que causa erro
                if "ETH/BNB" in pairs:
                    pairs.remove("ETH/BNB")
                    logger.info("Removendo ETH/BNB pois causa erro na API")
                logger.info("Usando pares padr√£o para swing trading")
    
    if previous_state and 'stats' in previous_state:
        logger.info("Estado anterior encontrado. Retomando opera√ß√£o...")
        stats = previous_state['stats']
        
        # Migra√ß√£o de chaves antigas para novas
        # Isso garante compatibilidade com estados salvos antes da atualiza√ß√£o
        key_mapping = {
            'trades_total': 'total_trades',
            'trades_win': 'winning_trades',
            'trades_loss': 'losing_trades'
        }
        
        # Migra chaves antigas para novas se necess√°rio
        for old_key, new_key in key_mapping.items():
            if old_key in stats and new_key not in stats:
                logger.info(f"Migrando estat√≠stica: {old_key} -> {new_key}")
                stats[new_key] = stats[old_key]
        
        # Garante que todas as chaves estat√≠sticas necess√°rias existam
        required_stats = {
            'total_trades': 0,
            'winning_trades': 0,
            'losing_trades': 0,
            'best_trade_profit': 0,
            'worst_trade_loss': 0,
            'initial_capital': capital,
            'current_capital': capital,
            'profit_history': []
        }
        
        for key, default_value in required_stats.items():
            if key not in stats:
                logger.warning(f"Chave {key} n√£o encontrada nas estat√≠sticas. Criando com valor padr√£o.")
                stats[key] = default_value
        
        # Converte a string de data de volta para datetime
        if 'start_time' in stats and isinstance(stats['start_time'], str):
            stats['start_time'] = datetime.fromisoformat(stats['start_time'])
        else:
            logger.warning("Chave start_time n√£o encontrada nas estat√≠sticas. Criando com valor atual.")
            stats['start_time'] = datetime.now()
        
        # Obt√©m hora da √∫ltima verifica√ß√£o
        if 'last_check_time' in previous_state and isinstance(previous_state['last_check_time'], str):
            last_check_time = datetime.fromisoformat(previous_state['last_check_time'])
        else:
            last_check_time = datetime.now() - timedelta(hours=1)
        
        # Verifica se as posi√ß√µes abertas foram salvas
        if 'open_positions' in previous_state and hasattr(strategy, 'open_positions'):
            # Converte posi√ß√µes abertas de volta para o formato original
            open_positions = {}
            for key, position in previous_state['open_positions'].items():
                # Se a posi√ß√£o tiver um campo 'time' em formato ISO, converta de volta para datetime
                if 'time' in position and isinstance(position['time'], str):
                    position['time'] = datetime.fromisoformat(position['time'])
                open_positions[key] = position
                
            strategy.open_positions = open_positions
            logger.info(f"Carregadas {len(strategy.open_positions)} posi√ß√µes abertas do estado anterior")
        
        # Mant√©m o capital atual ao inv√©s do salvo
        stats['current_capital'] = capital
        
        # Calcula quanto tempo passou desde o √∫ltimo check
        time_since_last_check = (datetime.now() - last_check_time).total_seconds() / 60  # em minutos
        logger.info(f"Estado anterior carregado - √öltima verifica√ß√£o: {time_since_last_check:.1f} minutos atr√°s")
        
        # Notifica retomada via Telegram
        if notifier:
            notifier.notify_status(f"üîÑ Robot-Crypt retomando opera√ß√µes!\n√öltima verifica√ß√£o: {time_since_last_check:.1f} minutos atr√°s")
    else:
        # Inicializa novas estat√≠sticas de trading
        stats = {
            'total_trades': 0,  # Renomeado de trades_total para corresponder ao DB
            'winning_trades': 0,  # Renomeado de trades_win para corresponder ao DB
            'losing_trades': 0,   # Renomeado de trades_loss para corresponder ao DB
            'initial_capital': capital,
            'current_capital': capital,
            'best_trade_profit': 0,
            'worst_trade_loss': 0,
            'start_time': datetime.now(),
            'profit_history': []
        }
        logger.info("Iniciando com novas estat√≠sticas - Nenhum estado anterior encontrado")
    
    # Contador para salvar estado periodicamente
    state_save_counter = 0
    
    # Vari√°vel para controlar tentativas e recupera√ß√£o
    consecutive_errors = 0
    max_consecutive_errors = 5
    
    # Loop principal
    try:
        while True:
            # Bloco para relat√≥rio de performance
            try:
                # Reporta estat√≠sticas a cada 24h
                runtime = (datetime.now() - stats['start_time']).total_seconds() / 3600
                if runtime >= 24 and runtime % 24 < 0.1:  # Aproximadamente a cada 24h
                    return_percent = ((stats['current_capital'] / stats['initial_capital']) - 1) * 100
                
                    logger.info("=" * 50)
                    logger.info(f"RELAT√ìRIO DE PERFORMANCE - {stats['start_time'].strftime('%d/%m/%Y')} at√© agora")
                    logger.info(f"Capital inicial: R${stats['initial_capital']:.2f}")
                    logger.info(f"Capital atual: R${stats['current_capital']:.2f} ({return_percent:+.2f}%)")
                    logger.info(f"Trades totais: {stats['total_trades']}")
                    
                    if stats['total_trades'] > 0:
                        win_rate = (stats['winning_trades'] / stats['total_trades']) * 100
                        logger.info(f"Win rate: {win_rate:.2f}%")
                        logger.info(f"Melhor trade: +{stats['best_trade_profit']:.2f}%")
                        logger.info(f"Pior trade: {stats['worst_trade_loss']:.2f}%")
                        
                    logger.info(f"Runtime: {runtime:.1f} horas")
                    logger.info("=" * 50)
                    
                    # Notifica via Telegram se configurado
                    if notifier:
                        notifier.notify_status(
                            f"üìä RELAT√ìRIO DE DESEMPENHO:\n"
                            f"üí∞ Capital: R${stats['current_capital']:.2f} ({return_percent:+.2f}%)\n"
                            f"üìà Trades: {stats['winning_trades']} ganhos, {stats['losing_trades']} perdas\n"
                            f"‚è±Ô∏è Tempo de execu√ß√£o: {runtime:.1f} horas"
                        )
            except Exception as e:
                logger.error(f"Erro ao gerar relat√≥rio de desempenho: {str(e)}")
                logger.exception("Detalhes do erro:")
            
            # In√≠cio do bloco principal de execu√ß√£o
            try:
                if not pairs:
                    logger.warning("Nenhum par de trading dispon√≠vel para an√°lise!")
                    
                    # Tenta definir alguns pares padr√£o se n√£o houver nenhum
                    if config.use_testnet:
                        pairs = ["BTC/USDT", "ETH/USDT", "BNB/USDT"]
                        logger.info("Definindo pares padr√£o para testnet: " + ", ".join(pairs))
                    else:
                        pairs = ["BTC/USDT", "ETH/USDT", "DOGE/USDT", "SHIB/USDT"]
                        logger.info("Definindo pares padr√£o para produ√ß√£o: " + ", ".join(pairs))
                    
                    # Notifica via Telegram
                    if notifier:
                        notifier.notify_status(f"‚ö†Ô∏è Nenhum par de trading encontrado. Definidos pares padr√£o: {', '.join(pairs)}")
            
                # Verifica se a estrat√©gia foi inicializada
                if strategy is None:
                    logger.warning("Estrat√©gia n√£o inicializada! Inicializando com base no capital...")
                
                # Inicializa a estrat√©gia com base no capital
                if capital < 300:
                    logger.info("Inicializando estrat√©gia de Scalping devido ao capital baixo")
                    strategy = ScalpingStrategy(config, binance)
                else:
                    logger.info("Inicializando estrat√©gia de Swing Trading")
                    strategy = SwingTradingStrategy(config, binance)
                
                # Notifica via Telegram
                    if notifier:
                        strategy_name = "Scalping" if capital < 300 else "Swing Trading"
                        notifier.notify_status(f"‚öôÔ∏è Inicializando estrat√©gia de {strategy_name}")
                
                # Analisa cada par configurado
                # Primeiro verifica e remove pares problem√°ticos conhecidos
                problematic_pairs = ["ETH/BNB"]
                for prob_pair in problematic_pairs:
                    if prob_pair in pairs:
                        logger.warning(f"Removendo par problem√°tico conhecido: {prob_pair}")
                        pairs.remove(prob_pair)
                        # Notifica via Telegram
                        if notifier:
                            notifier.notify_status(f"‚ö†Ô∏è Par {prob_pair} √© conhecido por causar problemas e foi removido da lista")

                for pair in pairs[:]:  # Cria uma c√≥pia para poder modificar a lista durante o loop
                    logger.info(f"Analisando par {pair}")
                    
                    # Envia notifica√ß√£o que iniciou an√°lise deste par
                    if notifier:
                        notifier.notify_status(f"üîé Iniciando an√°lise do par {pair}")
                
                # Tenta analisar o mercado com tratamento de erros espec√≠ficos
                try:
                    # Verifica se a estrat√©gia tem o m√©todo necess√°rio
                    if not hasattr(strategy, 'analyze_market') or not callable(getattr(strategy, 'analyze_market')):
                        logger.error(f"Estrat√©gia n√£o tem m√©todo 'analyze_market'. Tipo: {type(strategy)}")
                        continue
                    
                    # Analisa mercado e executa ordens conforme a estrat√©gia
                    should_trade, action, price = strategy.analyze_market(pair, notifier=notifier)
                except requests.exceptions.RequestException as e:
                    error_message = f"Erro na an√°lise do par {pair}: {str(e)}"
                    logger.error(error_message)
                    
                    # Se for um erro 400 (Bad Request), provavelmente o par n√£o existe
                    if hasattr(e, 'response') and e.response and e.response.status_code == 400:
                        logger.warning(f"Par {pair} n√£o dispon√≠vel. Removendo da lista de pares...")
                        
                        # Tenta remover o par da lista com seguran√ßa
                        try:
                            pairs.remove(pair)
                        except ValueError:
                            logger.warning(f"Par {pair} j√° foi removido da lista")
                        
                        # Notifica via Telegram
                        if notifier:
                            notifier.notify_status(f"‚ö†Ô∏è Par {pair} n√£o est√° dispon√≠vel e foi removido da lista")
                            
                        # Verifica se √© um par BNB e sugere inverter a ordem se for o caso
                        if '/BNB' in pair:
                            inverted_pair = f"BNB/{pair.split('/')[0]}"
                            logger.info(f"Tentando par invertido {inverted_pair} como alternativa...")
                            
                            # Notifica via Telegram sobre a tentativa de par invertido
                            if notifier:
                                notifier.notify_status(f"üîÑ Tentando par invertido {inverted_pair} como alternativa")
                    continue  # Pula para o pr√≥ximo par
                except Exception as e:
                    logger.error(f"Erro inesperado ao analisar par {pair}: {str(e)}")
                    logger.exception("Detalhes do erro:")
                    continue  # Pula para o pr√≥ximo par
                
                if should_trade:
                    if action == "buy":
                        success, order_info = strategy.execute_buy(pair, price)
                        
                        if success and notifier:
                            notifier.notify_trade(f"üõí COMPRA de {pair}", f"Pre√ßo: {price:.8f}\nQuantidade: {order_info['quantity']:.8f}")
                            
                    elif action == "sell":
                        success, order_info = strategy.execute_sell(pair, price)
                        
                        if success:
                            # Atualiza estat√≠sticas
                            stats['total_trades'] += 1
                            profit_percent = order_info['profit'] * 100
                            
                            if profit_percent > 0:
                                stats['winning_trades'] += 1
                                stats['best_trade_profit'] = max(stats['best_trade_profit'], profit_percent)
                            else:
                                stats['losing_trades'] += 1
                                stats['worst_trade_loss'] = min(stats['worst_trade_loss'], profit_percent)
                                
                            # Atualiza capital
                            stats['current_capital'] = config.get_balance(binance.get_account_info())
                            stats['profit_history'].append(profit_percent)
                            
                            # Notifica via Telegram
                            if notifier:
                                emoji = "üü¢" if profit_percent > 0 else "üî¥"
                                notifier.notify_trade(
                                    f"{emoji} VENDA de {pair}", 
                                    f"Pre√ßo: {price:.8f}\nLucro: {profit_percent:+.2f}%\nSaldo: R${stats['current_capital']:.2f}"
                                )
                
                # Atualiza informa√ß√µes da conta para verificar saldos dispon√≠veis
                try:
                    account_info = binance.get_account_info()
                    
                    # Atualiza o capital total
                    try:
                        capital = config.get_balance(account_info)
                    except Exception as balance_error:
                        logger.error(f"Erro ao calcular saldo: {str(balance_error)}")
                        # Mant√©m o valor anterior do capital
                        logger.warning("Mantendo valor anterior do capital devido a erro")
                    
                    # Verifica saldos das moedas principais
                    bnb_balance = 0
                    usdt_balance = 0
                    brl_balance = 0
                    
                    if 'balances' in account_info:
                        for balance in account_info.get('balances', []):
                            try:
                                asset = balance.get('asset', '')
                                free_amount = float(balance.get('free', '0'))
                                locked_amount = float(balance.get('locked', '0'))
                                total_amount = free_amount + locked_amount
                                
                                if asset == 'BNB' and total_amount > 0:
                                    bnb_balance = total_amount
                                elif asset == 'USDT' and total_amount > 0:
                                    usdt_balance = total_amount
                                elif asset == 'BRL' and total_amount > 0:
                                    brl_balance = total_amount
                            except Exception as balance_parse_error:
                                logger.error(f"Erro ao processar saldo da moeda {balance.get('asset', 'desconhecida')}: {str(balance_parse_error)}")
                    
                    logger.info(f"Saldos atualizados - BNB: {bnb_balance:.8f}, USDT: {usdt_balance:.2f}, BRL: {brl_balance:.2f}")
                except Exception as account_error:
                    logger.error(f"Erro ao atualizar informa√ß√µes da conta: {str(account_error)}")
                    logger.warning("Continuando execu√ß√£o com dados anteriores")
                    # N√£o atualiza os valores de saldo aqui, mantendo os anteriores
                
                # Verifica se estamos na fase correta com base no capital atual
                if capital < 300 and strategy.__class__.__name__ != "ScalpingStrategy":
                    logger.info("Migrando para estrat√©gia de Scalping (capital < R$300)")
                    strategy = ScalpingStrategy(config, binance)
                    
                    # Define os pares iniciais baseados nos saldos dispon√≠veis
                    pairs = []
                    
                    # Carrega pares de negocia√ß√£o da configura√ß√£o, se dispon√≠vel
                    config_pairs = config.trading_pairs if hasattr(config, 'trading_pairs') and config.trading_pairs else []
                    
                    # Se temos configura√ß√£o expl√≠cita de pares, usamos ela
                    if config_pairs:
                        logger.info(f"Usando pares configurados: {config_pairs}")
                        pairs = config_pairs
                    # Caso contr√°rio, definimos pares com base nas moedas dispon√≠veis
                    else:
                        if config.use_testnet:
                            pairs = ["BTC/USDT", "ETH/USDT", "BNB/USDT"]
                            logger.info("Usando pares compat√≠veis com testnet para scalping")
                        else:
                            # Adiciona pares com base nas moedas dispon√≠veis
                            if usdt_balance > 0:
                                pairs.extend(["BTC/USDT", "ETH/USDT", "DOGE/USDT", "SHIB/USDT"])
                                logger.info(f"Adicionando pares USDT para negocia√ß√£o com saldo dispon√≠vel de {usdt_balance:.2f} USDT")
                                
                            if brl_balance > 0:
                                pairs.extend(["BTC/BRL", "ETH/BRL"])
                                logger.info(f"Adicionando pares BRL para negocia√ß√£o com saldo dispon√≠vel de {brl_balance:.2f} BRL")
                    
                    # Se tiver saldo de BNB, adiciona pares espec√≠ficos para negociar BNB
                    if bnb_balance > 0.01:
                        logger.info(f"Adicionando pares de BNB para negocia√ß√£o com saldo dispon√≠vel de {bnb_balance:.8f} BNB")
                        if usdt_balance > 0:
                            pairs.append("BNB/USDT")
                            
                        if config.use_testnet:
                            pairs.append("BNB/BTC")
                        else:
                            pairs.extend(["BNB/BTC", "BNB/ETH"])
                            if brl_balance > 0:
                                pairs.append("BNB/BRL")
                    
                elif capital >= 300 and strategy.__class__.__name__ != "SwingTradingStrategy":
                    logger.info("Migrando para estrat√©gia de Swing Trading (capital >= R$300)")
                    strategy = SwingTradingStrategy(config, binance)
                    
                    # Define os pares baseados nos saldos dispon√≠veis
                    pairs = []
                    
                    # Carrega pares de negocia√ß√£o da configura√ß√£o, se dispon√≠vel
                    config_pairs = config.trading_pairs if hasattr(config, 'trading_pairs') and config.trading_pairs else []
                    
                    # Se temos configura√ß√£o expl√≠cita de pares, usamos ela
                    if config_pairs:
                        logger.info(f"Usando pares configurados: {config_pairs}")
                        pairs = config_pairs
                    # Caso contr√°rio, definimos pares com base nas moedas dispon√≠veis
                    else:
                        if config.use_testnet:
                            pairs = ["BTC/USDT", "ETH/USDT", "XRP/USDT", "LTC/USDT", "BNB/USDT"]
                            logger.info("Usando pares compat√≠veis com testnet para swing trading")
                        else:
                            # Adiciona pares com base nas moedas dispon√≠veis
                            if usdt_balance > 0:
                                pairs.extend(["BTC/USDT", "ETH/USDT", "DOGE/USDT", "SHIB/USDT", "FLOKI/USDT"])
                                logger.info(f"Adicionando pares USDT para negocia√ß√£o com saldo dispon√≠vel de {usdt_balance:.2f} USDT")
                                
                            if brl_balance > 0:
                                pairs.extend(["SHIB/BRL", "FLOKI/BRL", "DOGE/BRL"])
                                logger.info(f"Adicionando pares BRL para negocia√ß√£o com saldo dispon√≠vel de {brl_balance:.2f} BRL")
                    
                    # Se tiver saldo de BNB, adiciona pares espec√≠ficos para negociar BNB
                    if bnb_balance > 0.01:
                        logger.info(f"Adicionando pares de BNB para negocia√ß√£o com saldo dispon√≠vel de {bnb_balance:.8f} BNB")
                        if usdt_balance > 0:
                            pairs.append("BNB/USDT")
                            
                        if config.use_testnet:
                            pairs.extend(["BNB/BTC", "BNB/ETH"])
                        else:
                            pairs.extend(["BNB/BTC", "BNB/ETH"])
                            if brl_balance > 0:
                                pairs.append("BNB/BRL")
            
            # Incrementa contador de salvamento de estado
            state_save_counter += 1
            
            # Salva o estado a cada ciclo
            if state_save_counter >= 1:
                # Prepara o estado para ser salvo
                state_to_save = {
                    'stats': {
                        # Verifica se todas as chaves necess√°rias existem antes de salvar
                        'total_trades': stats.get('total_trades', 0),
                        'winning_trades': stats.get('winning_trades', 0),
                        'losing_trades': stats.get('losing_trades', 0),
                        'initial_capital': stats.get('initial_capital', config.get_balance(account_info)),
                        'current_capital': stats.get('current_capital', config.get_balance(account_info)),
                        'best_trade_profit': stats.get('best_trade_profit', 0),
                        'worst_trade_loss': stats.get('worst_trade_loss', 0),
                        'start_time': stats.get('start_time', datetime.now()).isoformat() if isinstance(stats.get('start_time', datetime.now()), datetime) else stats.get('start_time', datetime.now().isoformat()),
                        'profit_history': stats.get('profit_history', [])
                    },
                    'last_check_time': datetime.now().isoformat(),
                    'strategy_type': strategy.__class__.__name__,
                    'pairs': pairs
                }
                
                # Adiciona posi√ß√µes abertas se dispon√≠veis
                if hasattr(strategy, 'open_positions'):
                    # Convers√£o de posi√ß√µes abertas para formato serializ√°vel
                    open_positions_serialized = {}
                    for key, position in strategy.open_positions.items():
                        # Se a posi√ß√£o tiver um campo 'time', converta de datetime para string
                        pos_copy = position.copy()
                        if 'time' in pos_copy and isinstance(pos_copy['time'], datetime):
                            pos_copy['time'] = pos_copy['time'].isoformat()
                        open_positions_serialized[key] = pos_copy
                    
                    state_to_save['open_positions'] = open_positions_serialized
                
                # Salva o estado no arquivo JSON (legado) e no banco de dados
                save_state(state_to_save)
                db.save_app_state(state_to_save)
                
                # Atualiza estat√≠sticas di√°rias no banco de dados
                db.update_daily_stats(stats)
            
                # Resetamos contador de erros consecutivos quando completamos um ciclo com sucesso
                consecutive_errors = 0
                
                # Espera o intervalo configurado antes da pr√≥xima verifica√ß√£o
                logger.info(f"Aguardando {config.check_interval} segundos at√© pr√≥xima verifica√ß√£o")
                time.sleep(config.check_interval)
                
            except requests.exceptions.RequestException as e:
                consecutive_errors += 1
                logger.error(f"Erro de conex√£o [{consecutive_errors}/{max_consecutive_errors}]: {str(e)}")
                
                # Determina tempo de espera baseado na quantidade de erros consecutivos
                wait_time = min(60, 5 * (2 ** (consecutive_errors - 1)))  # 5, 10, 20, 40, 60 segundos
                
                if consecutive_errors >= max_consecutive_errors:
                    logger.error(f"Muitos erros consecutivos ({consecutive_errors}). Aplicando pausa longa.")
                    wait_time = 300  # 5 minutos de pausa ap√≥s muitos erros
                
                if hasattr(e, 'response') and e.response:
                    status_code = e.response.status_code
                    if status_code == 429:  # Rate limit
                        logger.error("Erro 429: Rate limit atingido. Pausa longa necess√°ria.")
                        wait_time = max(wait_time, 120)  # Pelo menos 2 minutos para rate limit
                
                logger.warning(f"Aguardando {wait_time} segundos antes de tentar novamente...")
                time.sleep(wait_time)
                logger.info("Retomando opera√ß√µes ap√≥s pausa por erro")
                
            except Exception as e:
                consecutive_errors += 1
                logger.error(f"Erro inesperado no loop principal [{consecutive_errors}/{max_consecutive_errors}]: {str(e)}")
                logger.exception("Detalhes do erro:")
                
                # Notifica via Telegram, mas continua a execu√ß√£o
                if notifier:
                    try:
                        notifier.notify_error(f"Erro recuper√°vel: {str(e)[:100]}")
                    except:
                        pass
                
                # Pausa para recupera√ß√£o
                wait_time = min(120, 10 * consecutive_errors)
                logger.warning(f"Aguardando {wait_time} segundos para recupera√ß√£o...")
                time.sleep(wait_time)
                
                # Se tivermos muitos erros consecutivos, pode ser um problema mais s√©rio
                if consecutive_errors >= max_consecutive_errors:
                    logger.error(f"Limite de erros consecutivos atingido ({max_consecutive_errors}). "
                                f"Reiniciando recursos para tentar recuperar.")
                    
                    # Tenta reiniciar recursos cr√≠ticos
                    try:
                        logger.info("Tentando reinicializar conex√£o com a Binance...")
                        if not config.simulation_mode:
                            binance = BinanceAPI(config.api_key, config.api_secret, testnet=config.use_testnet)
                        
                        # Reseta contador ap√≥s reinicializa√ß√£o
                        consecutive_errors = 0
                    except Exception as reinit_error:
                        logger.error(f"Erro ao reinicializar recursos: {str(reinit_error)}")
                
    except KeyboardInterrupt:
        logger.info("Bot interrompido pelo usu√°rio")
        # Notifica interrup√ß√£o via Telegram
        if notifier:
            notifier.notify_status("‚ö†Ô∏è Robot-Crypt interrompido pelo usu√°rio")
    except requests.exceptions.RequestException as e:
        error_message = f"Erro de conex√£o com a API: {str(e)}"
        logger.error(error_message)
        
        # Fornece orienta√ß√µes espec√≠ficas para erros de API comuns
        if hasattr(e, 'response') and e.response:
            status_code = e.response.status_code
            if status_code == 401:
                logger.error("Erro 401: Problema de autentica√ß√£o. Verifique suas credenciais.")
                if config.use_testnet:
                    logger.error("DICA: As credenciais da testnet expiram ap√≥s 30 dias. Obtenha novas em https://testnet.binance.vision/")
            elif status_code == 418 or status_code == 429:
                logger.error(f"Erro {status_code}: Limite de requisi√ß√µes atingido. Este √© um error fatal fora do loop principal.")
            elif status_code >= 500:
                logger.error(f"Erro {status_code}: Problema nos servidores da Binance. Este √© um error fatal fora do loop principal.")
        
        # Notifica erro via Telegram
        if notifier:
            notifier.notify_error(error_message)
    except Exception as e:
        error_message = f"Erro inesperado: {str(e)}"
        logger.error(error_message)
        logger.exception("Detalhes do erro:")
        
        # Notifica erro via Telegram
        if notifier:
            notifier.notify_error(error_message)
    finally:
        logger.info("Finalizando Robot-Crypt Bot")
        
        # Salva estado atual antes de finalizar (para poss√≠vel recupera√ß√£o)
        try:
            # Prepara o estado para ser salvo
            state_to_save = {
                'stats': {
                    # Verifica se todas as chaves necess√°rias existem antes de salvar
                    'total_trades': stats.get('total_trades', 0),
                    'winning_trades': stats.get('winning_trades', 0),
                    'losing_trades': stats.get('losing_trades', 0),
                    'initial_capital': stats.get('initial_capital', 100.0),
                    'current_capital': stats.get('current_capital', 100.0),
                    'best_trade_profit': stats.get('best_trade_profit', 0),
                    'worst_trade_loss': stats.get('worst_trade_loss', 0),
                    'start_time': stats.get('start_time', datetime.now()).isoformat() if isinstance(stats.get('start_time', datetime.now()), datetime) else stats.get('start_time', datetime.now().isoformat()),
                    'profit_history': stats.get('profit_history', [])
                },
                'last_check_time': datetime.now().isoformat(),
                'strategy_type': getattr(strategy, '__class__', type(None)).__name__ if strategy else 'None',
                'pairs': pairs or []
            }
            
            # Adiciona posi√ß√µes abertas se dispon√≠veis
            if hasattr(strategy, 'open_positions') and strategy.open_positions:
                # Convers√£o de posi√ß√µes abertas para formato serializ√°vel, se necess√°rio
                open_positions_serialized = {}
                for key, position in strategy.open_positions.items():
                    # Se a posi√ß√£o tiver um campo 'time', converta de datetime para string
                    pos_copy = position.copy()
                    if 'time' in pos_copy and isinstance(pos_copy['time'], datetime):
                        pos_copy['time'] = pos_copy['time'].isoformat()
                    open_positions_serialized[key] = pos_copy
                
                state_to_save['open_positions'] = open_positions_serialized
                logger.info(f"Salvando {len(strategy.open_positions)} posi√ß√µes abertas para recupera√ß√£o futura")
            
            # Salva o estado
            save_success = save_state(state_to_save, "app_state_final.json")
            if save_success:
                logger.info("Estado final salvo com sucesso para recupera√ß√£o futura")
        
        except Exception as save_error:
            logger.error(f"Erro ao salvar estado: {str(save_error)}")
        
        # Notifica finaliza√ß√£o via Telegram
        if notifier:
            notifier.notify_status("Robot-Crypt finalizado!")

if __name__ == "__main__":
    main()
