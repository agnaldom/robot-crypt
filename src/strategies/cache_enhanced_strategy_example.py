#!/usr/bin/env python3
"""
Exemplo de Estrat√©gia com Cache Hist√≥rico Integrado
==================================================

Este exemplo demonstra como usar o sistema de cache hist√≥rico
nas estrat√©gias de trading do Robot-Crypt.

O cache garante que:
1. SEMPRE consulta o banco de dados primeiro
2. S√≥ busca na API se n√£o encontrar dados suficientes
3. Salva automaticamente novos dados no banco
4. An√°lises s√£o MUITO mais r√°pidas ap√≥s o primeiro uso

Autor: Robot-Crypt Team
Data: 2024
"""

import logging
from typing import Dict, List, Optional, Tuple, Any
from datetime import datetime, timedelta

# Importa funcionalidades do cache (interface simplificada)
from src.cache import (
    get_market_data,      # Fun√ß√£o principal para obter dados hist√≥ricos
    get_latest_price,     # Fun√ß√£o para obter pre√ßo mais recente
    get_price_range,      # Fun√ß√£o para an√°lise de faixas de pre√ßo
    ensure_cache_ready,   # Garante que cache est√° inicializado
    is_cache_healthy,     # Verifica sa√∫de do cache
    maintain_cache_health # Manuten√ß√£o do cache
)

from src.core.logging_setup import logger


class CacheEnhancedTradingStrategy:
    """
    Estrat√©gia de trading que usa o cache hist√≥rico de forma otimizada.
    
    BENEF√çCIOS:
    - An√°lises 10x-100x mais r√°pidas ap√≥s cache inicial
    - Redu√ß√£o dr√°stica de chamadas √† API da Binance
    - Dados sempre atualizados automaticamente
    - Funciona offline com dados em cache
    """
    
    def __init__(self, config, binance_client):
        """
        Inicializa a estrat√©gia com cache hist√≥rico.
        
        Args:
            config: Configura√ß√£o do bot
            binance_client: Cliente da API Binance
        """
        self.config = config
        self.binance_client = binance_client
        self.name = "Cache Enhanced Strategy"
        
        # Estat√≠sticas de uso do cache
        self.cache_hits = 0
        self.api_calls = 0
        self.analysis_count = 0
        
        logger.info(f"‚úÖ {self.name} inicializada com cache hist√≥rico")
    
    async def initialize_strategy(self, symbols: List[str]) -> bool:
        """
        Inicializa a estrat√©gia garantindo que o cache esteja pronto.
        
        Args:
            symbols: Lista de s√≠mbolos que a estrat√©gia ir√° usar
            
        Returns:
            True se inicializa√ß√£o foi bem-sucedida
        """
        try:
            logger.info(f"üöÄ Inicializando estrat√©gia para {len(symbols)} s√≠mbolos...")
            
            # PASSO 1: Garante que o cache est√° pronto
            logger.info("üìä Preparando cache hist√≥rico...")
            cache_ready = await ensure_cache_ready(symbols)
            
            if cache_ready:
                logger.info("‚úÖ Cache hist√≥rico pronto!")
            else:
                logger.warning("‚ö†Ô∏è Cache n√£o p√¥de ser inicializado - usando API diretamente")
            
            # PASSO 2: Verifica sa√∫de do cache
            if is_cache_healthy():
                logger.info("üí™ Cache est√° saud√°vel e funcionando bem")
            else:
                logger.warning("‚ö†Ô∏è Cache apresenta problemas - executando manuten√ß√£o...")
                await maintain_cache_health()
            
            logger.info(f"üéØ Estrat√©gia inicializada para s√≠mbolos: {', '.join(symbols)}")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao inicializar estrat√©gia: {str(e)}")
            return False
    
    def analyze_market_with_cache(self, symbol: str) -> Dict[str, Any]:
        """
        Analisa o mercado usando dados do cache (SUPER R√ÅPIDO).
        
        Este m√©todo demonstra como usar o cache para an√°lises t√©cnicas.
        
        Args:
            symbol: S√≠mbolo para analisar (ex: 'BTCUSDT')
            
        Returns:
            Dict com an√°lise do mercado
        """
        try:
            self.analysis_count += 1
            logger.info(f"üìä Analisando {symbol} usando cache hist√≥rico...")
            
            # BUSCA DADOS DO CACHE (ou API se necess√°rio)
            # Essa linha FAZ TODA A M√ÅGICA: cache -> API -> salva no cache
            
            # Dados de 30 dias para an√°lise de tend√™ncia
            historical_data = get_market_data(
                symbol=symbol,
                interval='1d',
                period=30,  # √öltimos 30 dias
                force_refresh=False  # Prioriza cache
            )
            
            if not historical_data:
                logger.warning(f"‚ö†Ô∏è Nenhum dado encontrado para {symbol}")
                return {'error': 'Dados n√£o dispon√≠veis'}
            
            # AN√ÅLISE T√âCNICA COM DADOS DO CACHE
            analysis = self._perform_technical_analysis(symbol, historical_data)
            
            # OBT√âM PRE√áO ATUAL (cache first)
            current_price = get_latest_price(symbol)
            if current_price:
                analysis['current_price'] = current_price
                logger.info(f"üí∞ Pre√ßo atual de {symbol}: ${current_price:.2f}")
            
            # OBT√âM FAIXA DE PRE√áOS (an√°lise de suporte/resist√™ncia)
            price_range = get_price_range(symbol, days=30)
            if price_range:
                analysis['support_level'] = price_range['min']
                analysis['resistance_level'] = price_range['max']
                analysis['avg_price'] = price_range['avg']
                
                logger.info(f"üìà Faixa de {symbol}: ${price_range['min']:.2f} - ${price_range['max']:.2f}")
            
            # GERA SINAL DE TRADING
            trading_signal = self._generate_trading_signal(analysis)
            analysis['signal'] = trading_signal
            
            logger.info(f"üéØ An√°lise de {symbol} conclu√≠da: {trading_signal['action']}")
            return analysis
            
        except Exception as e:
            logger.error(f"‚ùå Erro na an√°lise de {symbol}: {str(e)}")
            return {'error': str(e)}
    
    def _perform_technical_analysis(self, symbol: str, data: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Executa an√°lise t√©cnica com os dados hist√≥ricos.
        
        Args:
            symbol: S√≠mbolo analisado
            data: Dados hist√≥ricos OHLCV
            
        Returns:
            Dict com indicadores t√©cnicos
        """
        try:
            # Extrai pre√ßos de fechamento
            closes = [float(candle['close']) for candle in data]
            highs = [float(candle['high']) for candle in data]
            lows = [float(candle['low']) for candle in data]
            volumes = [float(candle['volume']) for candle in data]
            
            # Calcula indicadores t√©cnicos b√°sicos
            sma_20 = sum(closes[:20]) / 20 if len(closes) >= 20 else sum(closes) / len(closes)
            sma_50 = sum(closes[:50]) / 50 if len(closes) >= 50 else sum(closes) / len(closes)
            
            # RSI simplificado
            rsi = self._calculate_simple_rsi(closes[:14]) if len(closes) >= 14 else 50
            
            # Volatilidade
            volatility = (max(closes) - min(closes)) / min(closes) * 100
            
            # Tend√™ncia
            trend = 'bullish' if closes[0] > sma_20 else 'bearish'
            
            # Volume m√©dio
            avg_volume = sum(volumes) / len(volumes)
            
            return {
                'symbol': symbol,
                'sma_20': sma_20,
                'sma_50': sma_50,
                'rsi': rsi,
                'volatility': volatility,
                'trend': trend,
                'avg_volume': avg_volume,
                'data_points': len(data),
                'analysis_time': datetime.now().isoformat()
            }
            
        except Exception as e:
            logger.error(f"‚ùå Erro na an√°lise t√©cnica: {str(e)}")
            return {}
    
    def _calculate_simple_rsi(self, prices: List[float], period: int = 14) -> float:
        """
        Calcula RSI simplificado.
        
        Args:
            prices: Lista de pre√ßos
            period: Per√≠odo para o RSI
            
        Returns:
            Valor do RSI (0-100)
        """
        try:
            if len(prices) < period:
                return 50  # Valor neutro
            
            gains = []
            losses = []
            
            for i in range(1, len(prices)):
                change = prices[i] - prices[i-1]
                if change > 0:
                    gains.append(change)
                    losses.append(0)
                else:
                    gains.append(0)
                    losses.append(abs(change))
            
            avg_gain = sum(gains[-period:]) / period
            avg_loss = sum(losses[-period:]) / period
            
            if avg_loss == 0:
                return 100
            
            rs = avg_gain / avg_loss
            rsi = 100 - (100 / (1 + rs))
            
            return rsi
            
        except Exception:
            return 50  # Valor neutro em caso de erro
    
    def _generate_trading_signal(self, analysis: Dict[str, Any]) -> Dict[str, Any]:
        """
        Gera sinal de trading baseado na an√°lise.
        
        Args:
            analysis: Resultado da an√°lise t√©cnica
            
        Returns:
            Dict com sinal de trading
        """
        try:
            signal = {
                'action': 'hold',
                'confidence': 0,
                'reason': '',
                'timestamp': datetime.now().isoformat()
            }
            
            if not analysis or 'current_price' not in analysis:
                signal['reason'] = 'Dados insuficientes'
                return signal
            
            current_price = analysis['current_price']
            sma_20 = analysis.get('sma_20', current_price)
            rsi = analysis.get('rsi', 50)
            support = analysis.get('support_level', current_price * 0.95)
            resistance = analysis.get('resistance_level', current_price * 1.05)
            
            # L√≥gica de trading simplificada
            confidence = 0
            reasons = []
            
            # Sinal de COMPRA
            if (current_price > sma_20 and rsi < 30 and 
                current_price <= support * 1.02):
                signal['action'] = 'buy'
                confidence += 70
                reasons.append('Pre√ßo pr√≥ximo ao suporte com RSI baixo')
            
            # Sinal de VENDA
            elif (current_price < sma_20 and rsi > 70 and 
                  current_price >= resistance * 0.98):
                signal['action'] = 'sell'
                confidence += 70
                reasons.append('Pre√ßo pr√≥ximo √† resist√™ncia com RSI alto')
            
            # Sinais adicionais
            if analysis.get('trend') == 'bullish':
                confidence += 15
                reasons.append('Tend√™ncia de alta')
            elif analysis.get('trend') == 'bearish':
                confidence -= 15
                reasons.append('Tend√™ncia de baixa')
            
            signal['confidence'] = max(0, min(100, confidence))
            signal['reason'] = '; '.join(reasons) if reasons else 'Sem sinais claros'
            
            return signal
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao gerar sinal: {str(e)}")
            return {
                'action': 'hold',
                'confidence': 0,
                'reason': f'Erro: {str(e)}',
                'timestamp': datetime.now().isoformat()
            }
    
    def get_strategy_stats(self) -> Dict[str, Any]:
        """
        Obt√©m estat√≠sticas da estrat√©gia e uso do cache.
        
        Returns:
            Dict com estat√≠sticas detalhadas
        """
        try:
            # Importa status do cache
            from src.cache import get_cache_status
            cache_status = get_cache_status()
            
            return {
                'strategy_name': self.name,
                'analysis_count': self.analysis_count,
                'cache_status': cache_status,
                'performance': {
                    'cache_efficiency': cache_status.get('cache_efficiency', 'N/A'),
                    'hit_rate': cache_status.get('hit_rate', 0),
                    'total_symbols': cache_status.get('cached_symbols', 0)
                },
                'last_updated': datetime.now().isoformat()
            }
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao obter estat√≠sticas: {str(e)}")
            return {'error': str(e)}
    
    async def maintain_strategy(self) -> None:
        """
        Executa manuten√ß√£o da estrat√©gia e do cache.
        Deve ser chamada periodicamente (ex: a cada hora).
        """
        try:
            logger.info("üîß Executando manuten√ß√£o da estrat√©gia...")
            
            # Executa manuten√ß√£o do cache
            await maintain_cache_health()
            
            # Verifica sa√∫de do cache
            if not is_cache_healthy():
                logger.warning("‚ö†Ô∏è Cache n√£o est√° saud√°vel ap√≥s manuten√ß√£o")
            
            # Mostra estat√≠sticas
            stats = self.get_strategy_stats()
            logger.info(f"üìä An√°lises realizadas: {stats.get('analysis_count', 0)}")
            logger.info(f"üìà Efici√™ncia do cache: {stats.get('performance', {}).get('cache_efficiency', 'N/A')}")
            
        except Exception as e:
            logger.error(f"‚ùå Erro na manuten√ß√£o da estrat√©gia: {str(e)}")


# EXEMPLO DE USO DA ESTRAT√âGIA
async def exemplo_uso_estrategia():
    """
    Exemplo pr√°tico de como usar a estrat√©gia com cache.
    """
    print("üß™ Demonstrando estrat√©gia com cache hist√≥rico...")
    
    # Simula configura√ß√£o e cliente Binance
    class MockConfig:
        pass
    
    class MockBinanceClient:
        pass
    
    config = MockConfig()
    binance_client = MockBinanceClient()
    
    # Cria estrat√©gia
    strategy = CacheEnhancedTradingStrategy(config, binance_client)
    
    # Lista de s√≠mbolos para trading
    symbols = ['BTCUSDT', 'ETHUSDT', 'BNBUSDT']
    
    # Inicializa estrat√©gia (garante cache pronto)
    success = await strategy.initialize_strategy(symbols)
    
    if success:
        print("‚úÖ Estrat√©gia inicializada com sucesso!")
        
        # Analisa cada s√≠mbolo (MUITO R√ÅPIDO ap√≥s cache)
        for symbol in symbols:
            print(f"\nüìä Analisando {symbol}...")
            analysis = strategy.analyze_market_with_cache(symbol)
            
            if 'error' not in analysis:
                signal = analysis.get('signal', {})
                print(f"üéØ Sinal: {signal.get('action', 'N/A')} "
                      f"(Confian√ßa: {signal.get('confidence', 0)}%)")
                print(f"üí≠ Raz√£o: {signal.get('reason', 'N/A')}")
            else:
                print(f"‚ùå Erro: {analysis['error']}")
        
        # Mostra estat√≠sticas
        print(f"\nüìà Estat√≠sticas da estrat√©gia:")
        stats = strategy.get_strategy_stats()
        print(f"   An√°lises realizadas: {stats.get('analysis_count', 0)}")
        print(f"   Efici√™ncia do cache: {stats.get('performance', {}).get('cache_efficiency', 'N/A')}")
        
        # Executa manuten√ß√£o
        await strategy.maintain_strategy()
        
        print("‚úÖ Demonstra√ß√£o conclu√≠da!")
    else:
        print("‚ùå Falha ao inicializar estrat√©gia")


if __name__ == "__main__":
    # Executa exemplo
    import asyncio
    asyncio.run(exemplo_uso_estrategia())
